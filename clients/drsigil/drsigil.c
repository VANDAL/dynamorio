#include <stddef.h> /* for offsetof */
#include <string.h> /* for strlen */

#include "drsigil.h"
#include "pthread_defines.h"
#include "start_stop_functions.h"

#include "drmgr.h"
#include "drwrap.h"
#include "drutil.h"
#include "drreg.h"


volatile bool roi = true;
/* unused currently */

static uint64 num_threads = 0;
/* Thread IDs are generated by the order of each thread's initialization */

int      tls_idx;
reg_id_t raw_tls_seg;
uint     raw_tls_memref_offs;

///////////////////////////////////////////////////////
// DynamoRIO event callbacks
///////////////////////////////////////////////////////
static dr_emit_flags_t
event_bb_instrument(void *drcontext, /*UNUSED*/ void *tag,
                    instrlist_t *ilist, instr_t *where,
                    /*UNUSED*/ bool for_trace,
                    /*UNUSED*/ bool translating,
                    /*UNUSED*/ void *user_data)
{
    if (!instr_is_app(where) ||
        !instr_get_app_pc(where))
        return DR_EMIT_DEFAULT;

    per_thread_t *tcxt = drmgr_get_tls_field(drcontext, tls_idx);

    /* reset the event block state if a new event block*/
    if (instrlist_first_app(ilist) == where ||
        instr_is_cti(instr_get_prev_app(where)))
        instrument_reset(drcontext, ilist, where, tcxt);

    /* set up the current iblock */
    instr_block_t *iblock = tcxt->iblocks + tcxt->iblock_count;
    iblock->instr = where;
    iblock->mem_ref_count = 0;
    iblock->comp_count = 0;
    tcxt->iblock_count += 1;
    tcxt->event_block_events += 1; //instr

    if (instr_reads_memory(where) || instr_writes_memory(where))
        instrument_mem_cache(drcontext, ilist, where, &iblock->mem_ref_count);
    tcxt->event_block_events += iblock->mem_ref_count;

    instrument_comp_cache(where, &iblock->comp_count, tcxt->current_iblock_comp);
    tcxt->event_block_events += iblock->comp_count;
    tcxt->current_iblock_comp += iblock->comp_count;

    if (instr_is_cti(where) || where == instrlist_last_app(ilist))
        instrument_sigil_events(drcontext, ilist, where, tcxt);

    return DR_EMIT_DEFAULT;
}


static dr_emit_flags_t
event_bb_app2app(void *drcontext, void *tag, instrlist_t *bb,
                 bool for_trace, bool translating)
{
    /* we transform string loops into regular loops so we can more easily
     * monitor every memory reference they make */
    /* XXX
     * We run into reachability problems,
     * as-per the documentation on 'drutil_expand_rep_string',
     * due to extra instrumentation added by Sigil2.
     *
     * We don't expect string loops to be significant in benchmarks,
     * so this should be OK.

    if (!drutil_expand_rep_string(drcontext, bb)) {
        DR_ASSERT(false);
    }

     */
    return DR_EMIT_DEFAULT;
}

static void
event_thread_init(void *drcontext)
{
    drreg_set_bb_properties(drcontext,
                            DRREG_CONTAINS_SPANNING_CONTROL_FLOW | DRREG_IGNORE_CONTROL_FLOW);

    per_thread_t *init = dr_thread_alloc(drcontext, sizeof(per_thread_t));
    init->memrefs      = dr_thread_alloc(drcontext, MEM_BUF_SIZE);
    init->comps        = dr_thread_alloc(drcontext, COMP_BUF_SIZE);
    init->iblocks      = dr_thread_alloc(drcontext, IBLOCK_BUF_SIZE);
    init->sync_ev      = dr_thread_alloc(drcontext, sizeof(SglSyncEv));

    if (init          == NULL ||
        init->memrefs == NULL ||
        init->comps   == NULL ||
        init->sync_ev == NULL ||
        init->iblocks == NULL)
        DR_ABORT_MSG("Failed to allocate per-thread data\n");

    init->thread_id = __sync_add_and_fetch(&num_threads,1);
    init->has_channel_lock = false;
    init->is_blocked = false;
    init->current_iblock_comp = init->comps;
    init->iblock_count = 0;
    init->event_block_events = 0;

    init->seg_base = dr_get_dr_segment_base(raw_tls_seg);
    PERTHR_PTR(init->seg_base)     = init;
    IBLOCKS_PTR(init->seg_base)    = init->iblocks;
    MEMREFBASE_PTR(init->seg_base) = init->memrefs;
    MEMREFCURR_PTR(init->seg_base) = init->memrefs;
    SGLEV_PTR(init->seg_base)      = NULL;
    SGLEND_PTR(init->seg_base)     = NULL;
    SGLUSED_PTR(init->seg_base)    = NULL;
    SGLSYNCEV_PTR(init->seg_base)  = NULL;
    ACTIVE(init->seg_base)         = true;
    /* TODO(someday) are we sure we want to activate
     * this thread right away? */
    drmgr_set_tls_field(drcontext, tls_idx, init);
}


static void
event_thread_exit(void *drcontext)
{
    per_thread_t *tcxt = drmgr_get_tls_field(drcontext, tls_idx);
    force_thread_flush(tcxt);
    dr_thread_free(drcontext, tcxt->memrefs, MEM_BUF_SIZE);
    dr_thread_free(drcontext, tcxt->comps, COMP_BUF_SIZE);
    dr_thread_free(drcontext, tcxt->iblocks, IBLOCK_BUF_SIZE);
    dr_thread_free(drcontext, tcxt->sync_ev, sizeof(SglSyncEv));
    dr_thread_free(drcontext, tcxt, sizeof(per_thread_t));
}


static void
event_exit(void)
{
    for(int i=0; i<clo.frontend_threads; ++i)
        terminate_IPC(i);

    if (!dr_raw_tls_cfree(raw_tls_memref_offs, MEMREF_TLS_COUNT))
        DR_ABORT_MSG("failed to free raw tls");

    if (!drmgr_unregister_thread_init_event(event_thread_init) ||
        !drmgr_unregister_thread_exit_event(event_thread_exit) ||
        !drmgr_unregister_tls_field(tls_idx))
        DR_ABORT_MSG("failed to unregister drmgr event callbacks");
    
    drutil_exit();
    drmgr_exit();
    drwrap_exit();
    drreg_exit();
}

static void
module_load_event(void *drcontext, const module_data_t *mod, bool loaded)
{
    app_pc towrap;

    if ((clo.start_func != NULL) &&
        (towrap = (app_pc)dr_get_proc_address(mod->handle, clo.start_func)) != NULL)
        drwrap_wrap(towrap, wrap_pre_start_func, wrap_post_start_func);

    if ((clo.stop_func != NULL) &&
        (towrap = (app_pc)dr_get_proc_address(mod->handle, clo.stop_func)) != NULL)
        drwrap_wrap(towrap, wrap_pre_stop_func, wrap_post_stop_func);

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, MAIN)) != NULL)
        drwrap_wrap(towrap, wrap_pre_start_at_main, wrap_post_start_at_main);

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_CREATE)) != NULL)
        drwrap_wrap(towrap, wrap_pre_pthread_create, wrap_post_pthread_create);

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_JOIN)) != NULL)
        drwrap_wrap(towrap, wrap_pre_pthread_join, wrap_post_pthread_join);

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_MUTEX_LOCK)) != NULL)
        drwrap_wrap(towrap, wrap_pre_pthread_mutex_lock, wrap_post_pthread_mutex_lock);

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_MUTEX_UNLOCK)) != NULL)
        drwrap_wrap(towrap, wrap_pre_pthread_mutex_unlock, wrap_post_pthread_mutex_unlock);

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_BARRIER)) != NULL)
        drwrap_wrap(towrap, wrap_pre_pthread_barrier, wrap_post_pthread_barrier);

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_COND_WAIT)) != NULL)
        drwrap_wrap(towrap, wrap_pre_pthread_cond_wait, wrap_post_pthread_cond_wait);

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_COND_SIG)) != NULL)
        drwrap_wrap(towrap, wrap_pre_pthread_cond_sig, wrap_post_pthread_cond_sig);

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_SPIN_LOCK)) != NULL)
        drwrap_wrap(towrap, wrap_pre_pthread_spin_lock, wrap_post_pthread_spin_lock);

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_SPIN_UNLOCK)) != NULL)
        drwrap_wrap(towrap, wrap_pre_pthread_spin_unlock, wrap_post_pthread_spin_unlock);
}


///////////////////////////////////////////////////////
// DynamoRIO client initialization
///////////////////////////////////////////////////////
DR_EXPORT void
dr_client_main(client_id_t id, int argc, const char *argv[])
{
    parse(argc, (char**)argv, &clo);

    dr_set_client_name("DrSigil",
                       "https://github.com/VANDAL/sigil2/issues");
    dr_register_exit_event(event_exit);

    drreg_options_t ops = {sizeof(ops), 5, false};

    if (!drmgr_init() ||
        !drutil_init() ||
        !drwrap_init() ||
        drreg_init(&ops) != DRREG_SUCCESS)
        DR_ABORT_MSG("failed to initialize DynamoRIO extensions");

    /* Specify priority relative to other instrumentation operations: */
    drmgr_priority_t priority = {
        sizeof(priority), /* size of struct */
        "sigil2",         /* name of our operation */
        NULL,             /* optional name of operation we should precede */
        NULL,             /* optional name of operation we should follow */
        0};               /* numeric priority */

    if (!drmgr_register_bb_instrumentation_event(NULL, event_bb_instrument, NULL) ||
        !drmgr_register_bb_app2app_event(event_bb_app2app, &priority) ||
        !drmgr_register_thread_init_event(event_thread_init) ||
        !drmgr_register_thread_exit_event(event_thread_exit) ||
        !drmgr_register_module_load_event(module_load_event))
        DR_ABORT_MSG("failed to register drmgr event callbacks");

    /* threads spawned so far */
    num_threads = 0;

    /* Initialize IPC */
    /* There are 'frontend_threads' number of channels */
    for(int i=0; i<clo.frontend_threads; ++i)
        init_IPC(i, clo.ipc_dir, clo.standalone);

    /* initialize thread local resources */
    tls_idx = drmgr_register_tls_field();

    /* use a raw tls for the mem ref buffer since it's accessed often */
    if (!dr_raw_tls_calloc(&raw_tls_seg, &raw_tls_memref_offs, MEMREF_TLS_COUNT, 0))
        DR_ABORT_MSG("failed to allocate raw tls");
}
