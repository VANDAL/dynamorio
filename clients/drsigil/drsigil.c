#include <stddef.h> /* for offsetof */
#include <string.h> /* for strlen */

#include "drsigil.h"
#include "pthread_defines.h"

#include "drmgr.h"
#include "drwrap.h"
#include "drutil.h"

///////////////////////////////////////////////////////
// Definitions
///////////////////////////////////////////////////////

int tls_idx;

/* Thread IDs are generated by the order of each thread's initialization */
static uint64 num_threads = 0;

/* Allocated TLS slot offsets */
enum {
    DRSIGIL_TLS_BUF_PTR = 0,
    DRSIGIL_TLS_COUNT, /* total number of TLS slots allocated */
};


///////////////////////////////////////////////////////
// Die with error msg
///////////////////////////////////////////////////////

void
dr_abort_w_msg(const char *msg)
{
    dr_fprintf(STDERR, "[DrSigil][ABORT]%s\n", msg);
    dr_abort();
}

///////////////////////////////////////////////////////
// Setting up clean call code cache
///////////////////////////////////////////////////////

/* A separate code cache to make
 * the clean function call leaner,
 * in the instrumentation.
 *
 * XXX ML: I think this reduces the amount
 * of context switching that will happen within
 * a basic block. */
app_pc code_cache;

static void
clean_call(void)
{
    void *drcontext  = dr_get_current_drcontext();
    per_thread_t *data = drmgr_get_tls_field(drcontext, tls_idx);
    flush((data->thread_id-1) % clo.frontend_threads, data);
}

static void
code_cache_init(void)
{
    void         *drcontext;
    instrlist_t  *ilist;
    instr_t      *where;
    byte         *end;

    drcontext  = dr_get_current_drcontext();
    code_cache = dr_nonheap_alloc(PAGE_SIZE,
                                  DR_MEMPROT_READ  |
                                  DR_MEMPROT_WRITE |
                                  DR_MEMPROT_EXEC);
    ilist = instrlist_create(drcontext);

    /* jump back to the DR's code cache (return address expected in XCX) */
    where = INSTR_CREATE_jmp_ind(drcontext, opnd_create_reg(DR_REG_XCX));
    instrlist_meta_append(ilist, where);

    /* The lean procecure simply performs a clean call, and then jump back */

    ///* clean call prior to jump back */
    dr_insert_clean_call(drcontext, ilist, where, (void *)clean_call, false, 0);

    /* Encodes the instructions into memory and then cleans up. */
    end = instrlist_encode(drcontext, ilist, code_cache, false);
    DR_ASSERT((end - code_cache) < PAGE_SIZE);
    instrlist_clear_and_destroy(drcontext, ilist);

    /* set the memory as just +rx now */
    dr_memory_protect(code_cache, PAGE_SIZE, DR_MEMPROT_READ | DR_MEMPROT_EXEC);
}

static void
code_cache_exit(void)
{
    dr_nonheap_free(code_cache, PAGE_SIZE);
}


///////////////////////////////////////////////////////
// DynamoRIO event callbacks
///////////////////////////////////////////////////////
static dr_emit_flags_t
event_bb_instrument(void *drcontext, /*UNUSED*/ void *tag,
                    instrlist_t *bb, instr_t *where,
                    /*UNUSED*/ bool for_trace,
                    /*UNUSED*/ bool translating,
                    /*UNUSED*/ void *user_data)
{
    /* some checks to make sure this is an
     * actual application instruction being
     * instrumented */
    if (instr_is_app(where) == false)
        return DR_EMIT_DEFAULT;
    if (instr_get_app_pc(where) == NULL)
        return DR_EMIT_DEFAULT;

    dr_fp_type_t fp_t;

    /*************************************/
    /* Sigil Context Event - Instruction */
    /*************************************/
    instrument_instr(drcontext, bb, where);

    /**********************/
    /* Sigil Memory Event */
    /**********************/
    if (instr_reads_memory(where) == true)
    {
        for (int i=0; i<instr_num_srcs(where); i++)
        {
            if (opnd_is_memory_reference(instr_get_src(where, i)))
            {
                instrument_mem(drcontext, bb, where, i, SGLPRIM_MEM_LOAD);
            }
        }
    }
    if (instr_writes_memory(where) == true)
    {
        for (int i=0; i<instr_num_dsts(where); i++)
        {
            if (opnd_is_memory_reference(instr_get_dst(where, i)))
            {
                instrument_mem(drcontext, bb, where, i, SGLPRIM_MEM_STORE);
            }
        }
    }

    /******************************/
    /* Sigil Compute Event - FLOP */
    /******************************/
    else if(instr_is_floating_ex(where, &fp_t))
    {
        if(fp_t == DR_FP_MATH)
        {
            /* set to flop for now
             * TODO how to get more interesting stats? (width, etc)
             */
            instrument_flop(drcontext, bb, where);
        }
    }

    /*****************************/
    /* Sigil Compute Event - IOP */
    /*****************************/
    /* Brute force checking of opcode */
    else
    {
        switch(instr_get_opcode(where))
        {
        case OP_add:
        case OP_xadd:
        case OP_paddq:
        case OP_adc:
        case OP_sub:
        case OP_sbb:
        case OP_mul:
        case OP_imul:
        case OP_div:
        case OP_idiv:
        case OP_neg:
        case OP_inc:
        case OP_dec:

        case OP_xor:
        case OP_and:
        case OP_or:
        case OP_bt:
        case OP_bts:
        case OP_btr:

        case OP_aas:
            instrument_iop(drcontext, bb, where);
        default:
            break;
        }
    }

    return DR_EMIT_DEFAULT;
}


static void
event_thread_init(void *drcontext)
{
    per_thread_t *init = dr_thread_alloc(drcontext, sizeof(per_thread_t));

    /* TODO does 'num_threads' have to be atomic for ARM?
     * If this is a problem, use dr_get_thread_id() */
    init->thread_id = ++num_threads;
    init->active = true;

    init->buf_ptr = dr_thread_alloc(drcontext, sizeof(BufferedSglEv)*BUFFER_SIZE);
    init->buf_base = init->buf_ptr;

    /* set buf_end to be negative of address of buffer end for the lea later */
    init->buf_end  = -(ptr_int_t)(init->buf_base + BUFFER_SIZE);

    drmgr_set_tls_field(drcontext, tls_idx, init);
}


static void
event_thread_exit(void *drcontext)
{
    per_thread_t *data = drmgr_get_tls_field(drcontext, tls_idx);

    force_flush((data->thread_id-1) % clo.frontend_threads, data);
    dr_printf("Leftover: %d\n", data->buf_ptr - data->buf_base);

    dr_thread_free(drcontext, data->buf_base, sizeof(BufferedSglEv)*BUFFER_SIZE);
    dr_thread_free(drcontext, data, sizeof(per_thread_t));
}


static void
event_exit(void)
{
    for(int i=0; i<clo.frontend_threads; ++i)
    {
        terminate_IPC(i);
    }

    if (!drmgr_unregister_thread_init_event(event_thread_init) ||
        !drmgr_unregister_thread_exit_event(event_thread_exit) ||
        !drmgr_unregister_tls_field(tls_idx))
    {
        dr_abort_w_msg("failed to unregister drmgr event callbacks");
    }

    drutil_exit();
    drmgr_exit();
    drwrap_exit();

    code_cache_exit();
}

static void
module_load_event(void *drcontext, const module_data_t *mod, bool loaded)
{
    app_pc towrap;

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_CREATE)) != NULL)
    {
        drwrap_wrap(towrap, wrap_pre_pthread_create, wrap_post_pthread_create);
    }

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_JOIN)) != NULL)
    {
        drwrap_wrap(towrap, wrap_pre_pthread_join, wrap_post_pthread_join);
    }

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_MUTEX_LOCK)) != NULL)
    {
        drwrap_wrap(towrap, wrap_pre_pthread_mutex_lock, wrap_post_pthread_mutex_lock);
    }

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_MUTEX_UNLOCK)) != NULL)
    {
        drwrap_wrap(towrap, wrap_pre_pthread_mutex_unlock, wrap_post_pthread_mutex_unlock);
    }

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_BARRIER)) != NULL)
    {
        drwrap_wrap(towrap, wrap_pre_pthread_barrier, wrap_post_pthread_barrier);
    }

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_COND_WAIT)) != NULL)
    {
        drwrap_wrap(towrap, wrap_pre_pthread_cond_wait, wrap_post_pthread_cond_wait);
    }

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_COND_SIG)) != NULL)
    {
        drwrap_wrap(towrap, wrap_pre_pthread_cond_sig, wrap_post_pthread_cond_sig);
    }

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_SPIN_LOCK)) != NULL)
    {
        drwrap_wrap(towrap, wrap_pre_pthread_spin_lock, wrap_post_pthread_spin_lock);
    }

    if ((towrap = (app_pc)dr_get_proc_address(mod->handle, P_SPIN_UNLOCK)) != NULL)
    {
        drwrap_wrap(towrap, wrap_pre_pthread_spin_unlock, wrap_post_pthread_spin_unlock);
    }
}


///////////////////////////////////////////////////////
// DynamoRIO client initialization
///////////////////////////////////////////////////////
DR_EXPORT void
dr_client_main(client_id_t id, int argc, const char *argv[])
{
    dr_set_client_name("DrSigil",
                       "https://github.com/mdlui/Sigil2/issues");

    dr_register_exit_event(event_exit);

    if (!drmgr_init() ||
        !drutil_init() ||
        !drwrap_init())
        DR_ASSERT(false);

    if (!drmgr_register_bb_instrumentation_event(NULL,
                                                 event_bb_instrument,
                                                 NULL) ||
        !drmgr_register_thread_init_event(event_thread_init) ||
        !drmgr_register_thread_exit_event(event_thread_exit) ||
        !drmgr_register_module_load_event(module_load_event))
    {
        dr_abort_w_msg("failed to register drmgr event callbacks");
    }

    parse(argc, (char **)argv, &clo);

    /* threads spawned so far */
    num_threads = 0;

    /* Initialize IPC */
    /* There are 'frontend_threads' number of channels */
    for(int i=0; i<clo.frontend_threads; ++i)
    {
        init_IPC(i, clo.tmp_dir);
    }

    /* initialize thread local resources */
    tls_idx = drmgr_register_tls_field();

    code_cache_init();
}
